/* automatically generated by rust-bindgen 0.59.1 */

pub type _u8 = u8;
pub type _u16 = u16;
pub type size_t = ::std::os::raw::c_ulong;
#[doc = " SBP callback function prototype definitions."]
pub type sbp_msg_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        sender_id: _u16,
        len: _u8,
        msg: *mut _u8,
        context: *mut ::std::os::raw::c_void,
    ),
>;
pub type sbp_frame_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        sender_id: _u16,
        msg_type: _u16,
        payload_len: _u8,
        payload: *mut _u8,
        frame_len: _u16,
        frame: *mut _u8,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sbp_callback_t {
    pub msg: sbp_msg_callback_t,
    pub frame: sbp_frame_callback_t,
}
#[test]
fn bindgen_test_layout_sbp_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<sbp_callback_t>(),
        8usize,
        concat!("Size of: ", stringify!(sbp_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sbp_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sbp_callback_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_callback_t>())).msg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_callback_t),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_callback_t>())).frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_callback_t),
            "::",
            stringify!(frame)
        )
    );
}
pub const sbp_cb_type_SBP_PAYLOAD_CALLBACK: sbp_cb_type = 0;
pub const sbp_cb_type_SBP_FRAME_CALLBACK: sbp_cb_type = 1;
pub const sbp_cb_type_SBP_CALLBACK_TYPE_COUNT: sbp_cb_type = 2;
#[doc = " SBP callback type enum:"]
#[doc = " SBP_PAYLOAD_CALLBACK are the original callbacks in libsbp without framing args"]
#[doc = " SBP_FRAME_CALLBACK are raw frame callbacks that include framing data as args."]
#[doc = " This enum is stored on each sbp_msg_callback_node struct to identify how"]
#[doc = " to cast the callback function pointer stored within."]
pub type sbp_cb_type = ::std::os::raw::c_uint;
#[doc = " SBP callback node."]
#[doc = " Forms a linked list of callbacks."]
#[doc = " \\note Must be statically allocated for use with sbp_register_callback()"]
#[doc = "       and sbp_register_frame_callback()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sbp_msg_callbacks_node {
    #[doc = "< Message ID associated with callback."]
    pub msg_type: _u16,
    #[doc = "< Pointer to callback function."]
    pub cb: sbp_callback_t,
    #[doc = "< Pointer to a context"]
    pub context: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to next node in list."]
    pub next: *mut sbp_msg_callbacks_node,
    #[doc = "< Enum that holds the type of callback."]
    pub cb_type: sbp_cb_type,
}
#[test]
fn bindgen_test_layout_sbp_msg_callbacks_node() {
    assert_eq!(
        ::std::mem::size_of::<sbp_msg_callbacks_node>(),
        40usize,
        concat!("Size of: ", stringify!(sbp_msg_callbacks_node))
    );
    assert_eq!(
        ::std::mem::align_of::<sbp_msg_callbacks_node>(),
        8usize,
        concat!("Alignment of ", stringify!(sbp_msg_callbacks_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).msg_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(msg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).cb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).cb_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(cb_type)
        )
    );
}
#[doc = " SBP callback node."]
#[doc = " Forms a linked list of callbacks."]
#[doc = " \\note Must be statically allocated for use with sbp_register_callback()"]
#[doc = "       and sbp_register_frame_callback()."]
pub type sbp_msg_callbacks_node_t = sbp_msg_callbacks_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct settings_s {
    _unused: [u8; 0],
}
#[doc = " @struct  settings_t"]
#[doc = ""]
#[doc = " @brief   Opaque context for settings."]
pub type settings_t = settings_s;
#[doc = "< Setting written"]
pub const settings_write_res_e_SETTINGS_WR_OK: settings_write_res_e = 0;
#[doc = "< Setting value invalid"]
pub const settings_write_res_e_SETTINGS_WR_VALUE_REJECTED: settings_write_res_e = 1;
#[doc = "< Setting does not exist"]
pub const settings_write_res_e_SETTINGS_WR_SETTING_REJECTED: settings_write_res_e = 2;
#[doc = "< Could not parse setting value"]
pub const settings_write_res_e_SETTINGS_WR_PARSE_FAILED: settings_write_res_e = 3;
#[doc = "< Setting is read only"]
pub const settings_write_res_e_SETTINGS_WR_READ_ONLY: settings_write_res_e = 4;
#[doc = "< Setting is not modifiable"]
pub const settings_write_res_e_SETTINGS_WR_MODIFY_DISABLED: settings_write_res_e = 5;
#[doc = "< System failure during setting"]
pub const settings_write_res_e_SETTINGS_WR_SERVICE_FAILED: settings_write_res_e = 6;
#[doc = "< Request wasn't replied in time"]
pub const settings_write_res_e_SETTINGS_WR_TIMEOUT: settings_write_res_e = 7;
#[doc = " @brief Settings write error codes"]
pub type settings_write_res_e = ::std::os::raw::c_uint;
#[doc = " @brief Settings write error codes"]
pub use self::settings_write_res_e as settings_write_res_t;
pub type settings_send_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        msg_type: u16,
        len: u8,
        payload: *mut u8,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_send_from_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        msg_type: u16,
        len: u8,
        payload: *mut u8,
        sbp_sender_id: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_wait_init_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type settings_wait_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_wait_deinit_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type settings_signal_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
pub type settings_lock_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
pub type settings_unlock_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
pub type settings_reg_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        msg_type: u16,
        cb: sbp_msg_callback_t,
        cb_context: *mut ::std::os::raw::c_void,
        node: *mut *mut sbp_msg_callbacks_node_t,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_unreg_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        node: *mut *mut sbp_msg_callbacks_node_t,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_log_t = ::std::option::Option<
    unsafe extern "C" fn(
        priority: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct settings_api_s {
    pub ctx: *mut ::std::os::raw::c_void,
    pub send: settings_send_t,
    pub send_from: settings_send_from_t,
    pub wait_init: settings_wait_init_t,
    pub wait: settings_wait_t,
    pub wait_deinit: settings_wait_deinit_t,
    pub signal: settings_signal_t,
    pub wait_thd: settings_wait_t,
    pub signal_thd: settings_signal_t,
    pub lock: settings_lock_t,
    pub unlock: settings_unlock_t,
    pub register_cb: settings_reg_cb_t,
    pub unregister_cb: settings_unreg_cb_t,
    pub log: settings_log_t,
    pub log_preformat: bool,
}
#[test]
fn bindgen_test_layout_settings_api_s() {
    assert_eq!(
        ::std::mem::size_of::<settings_api_s>(),
        120usize,
        concat!("Size of: ", stringify!(settings_api_s))
    );
    assert_eq!(
        ::std::mem::align_of::<settings_api_s>(),
        8usize,
        concat!("Alignment of ", stringify!(settings_api_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).send as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).send_from as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(send_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).wait_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(wait_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).wait as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).wait_deinit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(wait_deinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).signal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).wait_thd as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(wait_thd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).signal_thd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(signal_thd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).unlock as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).register_cb as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(register_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).unregister_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(unregister_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).log as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).log_preformat as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(log_preformat)
        )
    );
}
pub type settings_api_t = settings_api_s;
extern "C" {
    #[doc = " @brief   Create a settings context."]
    #[doc = " @details Create and initialize a settings context."]
    #[doc = ""]
    #[doc = " @return                  Pointer to the created context, or NULL if the"]
    #[doc = "                          operation failed."]
    pub fn settings_create(sender_id: u16, api_impl: *mut settings_api_t) -> *mut settings_t;
}
extern "C" {
    #[doc = " @brief   Destroy a settings context."]
    #[doc = " @details Deinitialize and destroy a settings context."]
    #[doc = ""]
    #[doc = " @note    The context pointer will be set to NULL by this function."]
    #[doc = ""]
    #[doc = " @param[inout] ctx        Double pointer to the context to destroy."]
    pub fn settings_destroy(ctx: *mut *mut settings_t);
}
extern "C" {
    #[doc = " @brief   Write a new value for registered setting of type str."]
    #[doc = " @details Call will block until write response or internal timeout."]
    #[doc = "          In case of multithreading, caller shall provide event object"]
    #[doc = "          that shall be used for waiting in wait_thd API function and"]
    #[doc = "          signaled in signal_thd API function. Also lock and unlock API"]
    #[doc = "          function implementations are mandatory when multithreading."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] event         Request specific event object."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] str           Value to be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval -1               Sending of the request failed."]
    #[doc = " @retval 0                The setting was written successfully."]
    #[doc = " @retval >0               Response returned an error @see settings_write_res_t"]
    pub fn settings_write_str(
        ctx: *mut settings_t,
        event: *mut ::std::os::raw::c_void,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> settings_write_res_t;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting of type int."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[out] value        Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read_int(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting of type float."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[out] value        Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read_float(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting of type str."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[out] str          Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = " @param[in] str_len       Size of the str buffer."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read_str(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        str_: *mut ::std::os::raw::c_char,
        str_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting of type bool."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[out] value        Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read_bool(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting based on index."]
    #[doc = " @details Call will block until read_by_idx response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] event         Request specific event object."]
    #[doc = " @param[in] idx           Index to read."]
    #[doc = " @param[out] section      String describing the setting section."]
    #[doc = " @param[in] section_len   Section str buffer size."]
    #[doc = " @param[out] name         String describing the setting name."]
    #[doc = " @param[in] name_len      Name str buffer size."]
    #[doc = " @param[out] value        String describing the setting value."]
    #[doc = " @param[in] value_len     Value str buffer size."]
    #[doc = " @param[out] type         String describing the setting type."]
    #[doc = " @param[in] type_len      Type str buffer size."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Next index is"]
    #[doc = " ready to be read."]
    #[doc = " @retval <0               Error."]
    #[doc = " @retval >0               Last index was read successfully. There are no more"]
    #[doc = " indexes to read."]
    pub fn settings_read_by_idx(
        ctx: *mut settings_t,
        event: *mut ::std::os::raw::c_void,
        idx: u16,
        section: *mut ::std::os::raw::c_char,
        section_len: size_t,
        name: *mut ::std::os::raw::c_char,
        name_len: size_t,
        value: *mut ::std::os::raw::c_char,
        value_len: size_t,
        type_: *mut ::std::os::raw::c_char,
        type_len: size_t,
    ) -> ::std::os::raw::c_int;
}
