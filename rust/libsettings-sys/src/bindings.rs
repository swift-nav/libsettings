/* automatically generated by rust-bindgen 0.59.1 */

pub const UINT8_MAX: u32 = 255;
pub const _RUSTC_BINDGEN_: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const SBP_OK: u32 = 0;
pub const SBP_OK_CALLBACK_EXECUTED: u32 = 1;
pub const SBP_OK_CALLBACK_UNDEFINED: u32 = 2;
pub const SBP_CALLBACK_ERROR: i32 = -1;
pub const SBP_CRC_ERROR: i32 = -2;
pub const SBP_SEND_ERROR: i32 = -3;
pub const SBP_NULL_ERROR: i32 = -4;
pub const SBP_WRITE_ERROR: i32 = -5;
pub const SBP_READ_ERROR: i32 = -6;
pub const SBP_SENDER_ID: u32 = 66;
pub const SBP_HEADER_LEN: u32 = 6;
pub const SBP_CRC_LEN: u32 = 2;
pub const SBP_MAX_PAYLOAD_LEN: u32 = 255;
pub const SBP_MAX_FRAME_LEN: u32 = 263;
pub const SBP_FRAME_OFFSET_PREAMBLE: u32 = 0;
pub const SBP_MSG_ALL: u32 = 0;
pub const SETTINGS_BUFLEN: u32 = 255;
pub type _s8 = i8;
pub type _s16 = i16;
pub type _s32 = i32;
pub type _s64 = i64;
pub type _u8 = u8;
pub type _u16 = u16;
pub type _u32 = u32;
pub type _u64 = u64;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " SBP callback function prototype definitions."]
pub type sbp_msg_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        sender_id: _u16,
        len: _u8,
        msg: *mut _u8,
        context: *mut ::std::os::raw::c_void,
    ),
>;
pub type sbp_frame_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        sender_id: _u16,
        msg_type: _u16,
        payload_len: _u8,
        payload: *mut _u8,
        frame_len: _u16,
        frame: *mut _u8,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sbp_callback_t {
    pub msg: sbp_msg_callback_t,
    pub frame: sbp_frame_callback_t,
}
#[test]
fn bindgen_test_layout_sbp_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<sbp_callback_t>(),
        8usize,
        concat!("Size of: ", stringify!(sbp_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sbp_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sbp_callback_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_callback_t>())).msg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_callback_t),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_callback_t>())).frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_callback_t),
            "::",
            stringify!(frame)
        )
    );
}
pub const sbp_cb_type_SBP_PAYLOAD_CALLBACK: sbp_cb_type = 0;
pub const sbp_cb_type_SBP_FRAME_CALLBACK: sbp_cb_type = 1;
pub const sbp_cb_type_SBP_CALLBACK_TYPE_COUNT: sbp_cb_type = 2;
#[doc = " SBP callback type enum:"]
#[doc = " SBP_PAYLOAD_CALLBACK are the original callbacks in libsbp without framing args"]
#[doc = " SBP_FRAME_CALLBACK are raw frame callbacks that include framing data as args."]
#[doc = " This enum is stored on each sbp_msg_callback_node struct to identify how"]
#[doc = " to cast the callback function pointer stored within."]
pub type sbp_cb_type = ::std::os::raw::c_uint;
#[doc = " SBP callback node."]
#[doc = " Forms a linked list of callbacks."]
#[doc = " \\note Must be statically allocated for use with sbp_register_callback()"]
#[doc = "       and sbp_register_frame_callback()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sbp_msg_callbacks_node {
    #[doc = "< Message ID associated with callback."]
    pub msg_type: _u16,
    #[doc = "< Pointer to callback function."]
    pub cb: sbp_callback_t,
    #[doc = "< Pointer to a context"]
    pub context: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to next node in list."]
    pub next: *mut sbp_msg_callbacks_node,
    #[doc = "< Enum that holds the type of callback."]
    pub cb_type: sbp_cb_type,
}
#[test]
fn bindgen_test_layout_sbp_msg_callbacks_node() {
    assert_eq!(
        ::std::mem::size_of::<sbp_msg_callbacks_node>(),
        40usize,
        concat!("Size of: ", stringify!(sbp_msg_callbacks_node))
    );
    assert_eq!(
        ::std::mem::align_of::<sbp_msg_callbacks_node>(),
        8usize,
        concat!("Alignment of ", stringify!(sbp_msg_callbacks_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).msg_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(msg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).cb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_msg_callbacks_node>())).cb_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_msg_callbacks_node),
            "::",
            stringify!(cb_type)
        )
    );
}
#[doc = " SBP callback node."]
#[doc = " Forms a linked list of callbacks."]
#[doc = " \\note Must be statically allocated for use with sbp_register_callback()"]
#[doc = "       and sbp_register_frame_callback()."]
pub type sbp_msg_callbacks_node_t = sbp_msg_callbacks_node;
#[doc = " State structure for processing SBP messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbp_state_t {
    pub state: sbp_state_t__bindgen_ty_1,
    pub msg_type: _u16,
    pub sender_id: _u16,
    pub crc: _u16,
    pub msg_len: _u8,
    pub frame_len: _u16,
    pub n_read: _u8,
    pub frame_buff: [_u8; 263usize],
    pub msg_buff: *mut _u8,
    pub io_context: *mut ::std::os::raw::c_void,
    pub sbp_msg_callbacks_head: *mut sbp_msg_callbacks_node_t,
}
pub const sbp_state_t_WAITING: ::std::os::raw::c_uint = 0;
pub const sbp_state_t_GET_TYPE: ::std::os::raw::c_uint = 1;
pub const sbp_state_t_GET_SENDER: ::std::os::raw::c_uint = 2;
pub const sbp_state_t_GET_LEN: ::std::os::raw::c_uint = 3;
pub const sbp_state_t_GET_MSG: ::std::os::raw::c_uint = 4;
pub const sbp_state_t_GET_CRC: ::std::os::raw::c_uint = 5;
pub type sbp_state_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_sbp_state_t() {
    assert_eq!(
        ::std::mem::size_of::<sbp_state_t>(),
        304usize,
        concat!("Size of: ", stringify!(sbp_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sbp_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sbp_state_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).msg_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(msg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).sender_id as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(sender_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).crc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).msg_len as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(msg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).frame_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(frame_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).n_read as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(n_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).frame_buff as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(frame_buff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).msg_buff as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(msg_buff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sbp_state_t>())).io_context as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(io_context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sbp_state_t>())).sbp_msg_callbacks_head as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(sbp_state_t),
            "::",
            stringify!(sbp_msg_callbacks_head)
        )
    );
}
extern "C" {
    #[doc = " \\}"]
    pub fn sbp_register_callback(
        s: *mut sbp_state_t,
        msg_type: _u16,
        cb: sbp_msg_callback_t,
        context: *mut ::std::os::raw::c_void,
        node: *mut sbp_msg_callbacks_node_t,
    ) -> _s8;
}
extern "C" {
    pub fn sbp_register_frame_callback(
        s: *mut sbp_state_t,
        msg_type: _u16,
        cb: sbp_frame_callback_t,
        context: *mut ::std::os::raw::c_void,
        node: *mut sbp_msg_callbacks_node_t,
    ) -> _s8;
}
extern "C" {
    pub fn sbp_register_all_msg_callback(
        s: *mut sbp_state_t,
        cb: sbp_frame_callback_t,
        context: *mut ::std::os::raw::c_void,
        node: *mut sbp_msg_callbacks_node_t,
    ) -> _s8;
}
extern "C" {
    pub fn sbp_remove_callback(s: *mut sbp_state_t, node: *mut sbp_msg_callbacks_node_t) -> _s8;
}
extern "C" {
    pub fn sbp_clear_callbacks(s: *mut sbp_state_t);
}
extern "C" {
    pub fn sbp_state_init(s: *mut sbp_state_t);
}
extern "C" {
    pub fn sbp_state_set_io_context(s: *mut sbp_state_t, context: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sbp_process(
        s: *mut sbp_state_t,
        read: ::std::option::Option<
            unsafe extern "C" fn(
                buff: *mut _u8,
                n: _u32,
                context: *mut ::std::os::raw::c_void,
            ) -> _s32,
        >,
    ) -> _s8;
}
extern "C" {
    pub fn sbp_process_payload(
        s: *mut sbp_state_t,
        sender_id: _u16,
        msg_type: _u16,
        msg_len: _u8,
        payload: *mut _u8,
    ) -> _s8;
}
extern "C" {
    pub fn sbp_process_frame(
        s: *mut sbp_state_t,
        sender_id: _u16,
        msg_type: _u16,
        payload_len: _u8,
        payload: *mut _u8,
        frame_len: _u16,
        frame: *mut _u8,
        cb_mask: _u8,
    ) -> _s8;
}
extern "C" {
    pub fn sbp_send_message(
        s: *mut sbp_state_t,
        msg_type: _u16,
        sender_id: _u16,
        len: _u8,
        payload: *mut _u8,
        write: ::std::option::Option<
            unsafe extern "C" fn(
                buff: *mut _u8,
                n: _u32,
                context: *mut ::std::os::raw::c_void,
            ) -> _s32,
        >,
    ) -> _s8;
}
#[doc = " @brief   Settings type."]
pub type settings_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct settings_s {
    _unused: [u8; 0],
}
#[doc = " @struct  settings_t"]
#[doc = ""]
#[doc = " @brief   Opaque context for settings."]
pub type settings_t = settings_s;
#[doc = "< Integer. 8, 16, or 32 bits."]
pub const SETTINGS_TYPE_INT: ::std::os::raw::c_uint = 0;
#[doc = "< Float. Single or double precision."]
pub const SETTINGS_TYPE_FLOAT: ::std::os::raw::c_uint = 1;
#[doc = "< String."]
pub const SETTINGS_TYPE_STRING: ::std::os::raw::c_uint = 2;
#[doc = "< Boolean."]
pub const SETTINGS_TYPE_BOOL: ::std::os::raw::c_uint = 3;
#[doc = " @brief   Standard settings type definitions."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = "< Setting registered, requested value used"]
pub const settings_reg_res_e_SETTINGS_REG_OK: settings_reg_res_e = 0;
pub const settings_reg_res_e_SETTINGS_REG_OK_PERM: settings_reg_res_e = 1;
pub const settings_reg_res_e_SETTINGS_REG_REGISTERED: settings_reg_res_e = 2;
#[doc = "< Could not parse setting"]
pub const settings_reg_res_e_SETTINGS_REG_PARSE_FAILED: settings_reg_res_e = 3;
#[doc = " @brief Settings register error codes"]
pub type settings_reg_res_e = ::std::os::raw::c_uint;
#[doc = " @brief Settings register error codes"]
pub use self::settings_reg_res_e as settings_reg_res_t;
#[doc = "< Setting written"]
pub const settings_write_res_e_SETTINGS_WR_OK: settings_write_res_e = 0;
#[doc = "< Setting value invalid"]
pub const settings_write_res_e_SETTINGS_WR_VALUE_REJECTED: settings_write_res_e = 1;
#[doc = "< Setting does not exist"]
pub const settings_write_res_e_SETTINGS_WR_SETTING_REJECTED: settings_write_res_e = 2;
#[doc = "< Could not parse setting value"]
pub const settings_write_res_e_SETTINGS_WR_PARSE_FAILED: settings_write_res_e = 3;
#[doc = "< Setting is read only"]
pub const settings_write_res_e_SETTINGS_WR_READ_ONLY: settings_write_res_e = 4;
#[doc = "< Setting is not modifiable"]
pub const settings_write_res_e_SETTINGS_WR_MODIFY_DISABLED: settings_write_res_e = 5;
#[doc = "< System failure during setting"]
pub const settings_write_res_e_SETTINGS_WR_SERVICE_FAILED: settings_write_res_e = 6;
#[doc = "< Request wasn't replied in time"]
pub const settings_write_res_e_SETTINGS_WR_TIMEOUT: settings_write_res_e = 7;
#[doc = " @brief Settings write error codes"]
pub type settings_write_res_e = ::std::os::raw::c_uint;
#[doc = " @brief Settings write error codes"]
pub use self::settings_write_res_e as settings_write_res_t;
pub type settings_send_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        msg_type: u16,
        len: u8,
        payload: *mut u8,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_send_from_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        msg_type: u16,
        len: u8,
        payload: *mut u8,
        sbp_sender_id: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_wait_init_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type settings_wait_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_wait_deinit_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type settings_signal_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
pub type settings_wait_thd_t = ::std::option::Option<
    unsafe extern "C" fn(
        event: *mut ::std::os::raw::c_void,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_signal_thd_t =
    ::std::option::Option<unsafe extern "C" fn(event: *mut ::std::os::raw::c_void)>;
pub type settings_lock_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
pub type settings_unlock_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
pub type settings_reg_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        msg_type: u16,
        cb: sbp_msg_callback_t,
        cb_context: *mut ::std::os::raw::c_void,
        node: *mut *mut sbp_msg_callbacks_node_t,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_unreg_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        node: *mut *mut sbp_msg_callbacks_node_t,
    ) -> ::std::os::raw::c_int,
>;
pub type settings_log_t = ::std::option::Option<
    unsafe extern "C" fn(
        priority: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct settings_api_s {
    pub ctx: *mut ::std::os::raw::c_void,
    pub send: settings_send_t,
    pub send_from: settings_send_from_t,
    pub wait_init: settings_wait_init_t,
    pub wait: settings_wait_t,
    pub wait_deinit: settings_wait_deinit_t,
    pub signal: settings_signal_t,
    pub wait_thd: settings_wait_t,
    pub signal_thd: settings_signal_t,
    pub lock: settings_lock_t,
    pub unlock: settings_unlock_t,
    pub register_cb: settings_reg_cb_t,
    pub unregister_cb: settings_unreg_cb_t,
    pub log: settings_log_t,
    pub log_preformat: bool,
}
#[test]
fn bindgen_test_layout_settings_api_s() {
    assert_eq!(
        ::std::mem::size_of::<settings_api_s>(),
        120usize,
        concat!("Size of: ", stringify!(settings_api_s))
    );
    assert_eq!(
        ::std::mem::align_of::<settings_api_s>(),
        8usize,
        concat!("Alignment of ", stringify!(settings_api_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).send as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).send_from as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(send_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).wait_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(wait_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).wait as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).wait_deinit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(wait_deinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).signal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).wait_thd as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(wait_thd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).signal_thd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(signal_thd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).unlock as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).register_cb as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(register_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).unregister_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(unregister_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).log as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<settings_api_s>())).log_preformat as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(settings_api_s),
            "::",
            stringify!(log_preformat)
        )
    );
}
pub type settings_api_t = settings_api_s;
#[doc = " @brief   Settings notify callback."]
#[doc = " @details Signature of a user-provided callback function to be executed"]
#[doc = "          after a setting value is updated."]
#[doc = ""]
#[doc = " @note    The setting value will be updated _before_ the callback is executed."]
#[doc = "          If the callback returns an error, the setting value will be"]
#[doc = "          reverted to the previous value."]
#[doc = ""]
#[doc = " @param[in] context       Pointer to the user-provided context."]
#[doc = ""]
#[doc = " @return                  The operation result."]
#[doc = " @retval 0                Success. The updated setting value is acceptable."]
#[doc = " @retval -1               The updated setting value should be reverted."]
pub type settings_notify_fn = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief   Create a settings context."]
    #[doc = " @details Create and initialize a settings context."]
    #[doc = ""]
    #[doc = " @return                  Pointer to the created context, or NULL if the"]
    #[doc = "                          operation failed."]
    pub fn settings_create(sender_id: u16, api_impl: *mut settings_api_t) -> *mut settings_t;
}
extern "C" {
    #[doc = " @brief   Destroy a settings context."]
    #[doc = " @details Deinitialize and destroy a settings context."]
    #[doc = ""]
    #[doc = " @note    The context pointer will be set to NULL by this function."]
    #[doc = ""]
    #[doc = " @param[inout] ctx        Double pointer to the context to destroy."]
    pub fn settings_destroy(ctx: *mut *mut settings_t);
}
extern "C" {
    #[doc = " @brief   Register an enum type."]
    #[doc = " @details Register an enum as a settings type."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] enum_names    Null-terminated array of strings corresponding to"]
    #[doc = "                          the possible enum values."]
    #[doc = " @param[out] type         Pointer to be set to the allocated settings type."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The enum type was registered successfully."]
    #[doc = " @retval -1               An error occurred."]
    pub fn settings_register_enum(
        ctx: *mut settings_t,
        enum_names: *const *const ::std::os::raw::c_char,
        type_: *mut settings_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Register a setting."]
    #[doc = " @details Register a persistent, user-facing setting."]
    #[doc = ""]
    #[doc = " @note    The specified notify function will be executed from this function"]
    #[doc = "          during initial registration."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] var           Address of the setting variable. This location will"]
    #[doc = "                          be written directly by the settings module."]
    #[doc = " @param[in] var_len       Size of the setting variable."]
    #[doc = " @param[in] type          Type of the setting."]
    #[doc = " @param[in] notify        Notify function to be executed when the setting is"]
    #[doc = "                          written and during initial registration."]
    #[doc = " @param[in] notify_context Context passed to the notify function."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was registered successfully."]
    #[doc = " @retval -1               An error occurred."]
    pub fn settings_register_setting(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        var: *mut ::std::os::raw::c_void,
        var_len: size_t,
        type_: settings_type_t,
        notify: settings_notify_fn,
        notify_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Register a read-only setting."]
    #[doc = " @details Register a read-only, user-facing setting."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] var           Address of the setting variable. This location will"]
    #[doc = "                          be written directly by the settings module."]
    #[doc = " @param[in] var_len       Size of the setting variable."]
    #[doc = " @param[in] type          Type of the setting."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was registered successfully."]
    #[doc = " @retval -1               An error occurred."]
    pub fn settings_register_readonly(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        var: *const ::std::os::raw::c_void,
        var_len: size_t,
        type_: settings_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Create and add a watch only setting."]
    #[doc = " @details Create and add a watch only setting."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] var           Address of the setting variable. This location will"]
    #[doc = "                          be written directly by the settings module."]
    #[doc = " @param[in] var_len       Size of the setting variable."]
    #[doc = " @param[in] type          Type of the setting."]
    #[doc = " @param[in] notify        Notify function to be executed when the setting is"]
    #[doc = "                          updated by a write response"]
    #[doc = " @param[in] notify_context Context passed to the notify function."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was registered successfully."]
    #[doc = " @retval -1               An error occurred."]
    pub fn settings_register_watch(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        var: *mut ::std::os::raw::c_void,
        var_len: size_t,
        type_: settings_type_t,
        notify: settings_notify_fn,
        notify_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Write a new value for registered setting."]
    #[doc = " @details Call will block until write response or internal timeout."]
    #[doc = "          In case of multithreading, caller shall provide event object"]
    #[doc = "          that shall be used for waiting in wait_thd API function and"]
    #[doc = "          signaled in signal_thd API function. Also lock and unlock API"]
    #[doc = "          function implementations are mandatory when multithreading."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] event         Request specific event object."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] value         Address of the value variable."]
    #[doc = " @param[in] value_len     Size of the value variable."]
    #[doc = " @param[in] type          Type of the setting."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval -1               Sending of the request failed."]
    #[doc = " @retval 0                The setting was written successfully."]
    #[doc = " @retval >0               Response returned an error @see settings_write_res_t"]
    pub fn settings_write(
        ctx: *mut settings_t,
        event: *mut ::std::os::raw::c_void,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_void,
        value_len: size_t,
        type_: settings_type_t,
    ) -> settings_write_res_t;
}
extern "C" {
    #[doc = " @brief   Write a new value for registered setting of type int."]
    #[doc = " @details Call will block until write response or internal timeout."]
    #[doc = "          In case of multithreading, caller shall provide event object"]
    #[doc = "          that shall be used for waiting in wait_thd API function and"]
    #[doc = "          signaled in signal_thd API function. Also lock and unlock API"]
    #[doc = "          function implementations are mandatory when multithreading."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] event         Request specific event object."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] value         Value to be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval -1               Sending of the request failed."]
    #[doc = " @retval 0                The setting was written successfully."]
    #[doc = " @retval >0               Response returned an error @see settings_write_res_t"]
    pub fn settings_write_int(
        ctx: *mut settings_t,
        event: *mut ::std::os::raw::c_void,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> settings_write_res_t;
}
extern "C" {
    #[doc = " @brief   Write a new value for registered setting of type float."]
    #[doc = " @details Call will block until write response or internal timeout."]
    #[doc = "          In case of multithreading, caller shall provide event object"]
    #[doc = "          that shall be used for waiting in wait_thd API function and"]
    #[doc = "          signaled in signal_thd API function. Also lock and unlock API"]
    #[doc = "          function implementations are mandatory when multithreading."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] event         Request specific event object."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] value         Value to be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval -1               Sending of the request failed."]
    #[doc = " @retval 0                The setting was written successfully."]
    #[doc = " @retval >0               Response returned an error @see settings_write_res_t"]
    pub fn settings_write_float(
        ctx: *mut settings_t,
        event: *mut ::std::os::raw::c_void,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: f32,
    ) -> settings_write_res_t;
}
extern "C" {
    #[doc = " @brief   Write a new value for registered setting of type str."]
    #[doc = " @details Call will block until write response or internal timeout."]
    #[doc = "          In case of multithreading, caller shall provide event object"]
    #[doc = "          that shall be used for waiting in wait_thd API function and"]
    #[doc = "          signaled in signal_thd API function. Also lock and unlock API"]
    #[doc = "          function implementations are mandatory when multithreading."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] event         Request specific event object."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] str           Value to be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval -1               Sending of the request failed."]
    #[doc = " @retval 0                The setting was written successfully."]
    #[doc = " @retval >0               Response returned an error @see settings_write_res_t"]
    pub fn settings_write_str(
        ctx: *mut settings_t,
        event: *mut ::std::os::raw::c_void,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> settings_write_res_t;
}
extern "C" {
    #[doc = " @brief   Write a new value for registered setting of type bool."]
    #[doc = " @details Call will block until write response or internal timeout."]
    #[doc = "          In case of multithreading, caller shall provide event object"]
    #[doc = "          that shall be used for waiting in wait_thd API function and"]
    #[doc = "          signaled in signal_thd API function. Also lock and unlock API"]
    #[doc = "          function implementations are mandatory when multithreading."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] event         Request specific event object."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] value         Value to be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval -1               Sending of the request failed."]
    #[doc = " @retval 0                The setting was written successfully."]
    #[doc = " @retval >0               Response returned an error @see settings_write_res_t"]
    pub fn settings_write_bool(
        ctx: *mut settings_t,
        event: *mut ::std::os::raw::c_void,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: bool,
    ) -> settings_write_res_t;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[in] value         Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = " @param[in] value_len     Size of the value variable."]
    #[doc = " @param[in] type          Type of the setting."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
        value_len: size_t,
        type_: settings_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting of type int."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[out] value        Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read_int(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting of type float."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[out] value        Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read_float(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting of type str."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[out] str          Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = " @param[in] str_len       Size of the str buffer."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read_str(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        str_: *mut ::std::os::raw::c_char,
        str_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting of type bool."]
    #[doc = " @details Call will block until read response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] section       String describing the setting section."]
    #[doc = " @param[in] name          String describing the setting name."]
    #[doc = " @param[out] value        Address of the variable where the read value shall"]
    #[doc = " be written."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Error otherwise."]
    pub fn settings_read_bool(
        ctx: *mut settings_t,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Read value of registered setting based on index."]
    #[doc = " @details Call will block until read_by_idx response or internal timeout."]
    #[doc = ""]
    #[doc = " @param[in] ctx           Pointer to the context to use."]
    #[doc = " @param[in] event         Request specific event object."]
    #[doc = " @param[in] idx           Index to read."]
    #[doc = " @param[out] section      String describing the setting section."]
    #[doc = " @param[in] section_len   Section str buffer size."]
    #[doc = " @param[out] name         String describing the setting name."]
    #[doc = " @param[in] name_len      Name str buffer size."]
    #[doc = " @param[out] value        String describing the setting value."]
    #[doc = " @param[in] value_len     Value str buffer size."]
    #[doc = " @param[out] type         String describing the setting type."]
    #[doc = " @param[in] type_len      Type str buffer size."]
    #[doc = ""]
    #[doc = " @return                  The operation result."]
    #[doc = " @retval 0                The setting was read successfully. Next index is"]
    #[doc = " ready to be read."]
    #[doc = " @retval <0               Error."]
    #[doc = " @retval >0               Last index was read successfully. There are no more"]
    #[doc = " indexes to read."]
    pub fn settings_read_by_idx(
        ctx: *mut settings_t,
        event: *mut ::std::os::raw::c_void,
        idx: u16,
        section: *mut ::std::os::raw::c_char,
        section_len: size_t,
        name: *mut ::std::os::raw::c_char,
        name_len: size_t,
        value: *mut ::std::os::raw::c_char,
        value_len: size_t,
        type_: *mut ::std::os::raw::c_char,
        type_len: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libsettings_ctx_s {
    pub lock: *mut ::std::os::raw::c_void,
    pub condvar: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_libsettings_ctx_s() {
    assert_eq!(
        ::std::mem::size_of::<libsettings_ctx_s>(),
        16usize,
        concat!("Size of: ", stringify!(libsettings_ctx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<libsettings_ctx_s>(),
        8usize,
        concat!("Alignment of ", stringify!(libsettings_ctx_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libsettings_ctx_s>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libsettings_ctx_s),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libsettings_ctx_s>())).condvar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libsettings_ctx_s),
            "::",
            stringify!(condvar)
        )
    );
}
pub type libsettings_ctx_t = libsettings_ctx_s;
extern "C" {
    pub fn c_libsettings_init(ctx: *mut libsettings_ctx_t) -> bool;
}
extern "C" {
    pub fn c_libsettings_lock(ctx: *mut libsettings_ctx_t) -> bool;
}
extern "C" {
    pub fn c_libsettings_unlock(ctx: *mut libsettings_ctx_t) -> bool;
}
extern "C" {
    pub fn c_libsettings_wait(ctx: *mut libsettings_ctx_t, ms: u32) -> bool;
}
extern "C" {
    pub fn c_libsettings_signal(ctx: *mut libsettings_ctx_t) -> bool;
}
extern "C" {
    pub fn c_libsettings_destroy(ctx: *mut libsettings_ctx_t) -> bool;
}
